% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getScheme.R
\name{getScheme}
\alias{getScheme}
\title{Get a Classification \code{Field} from a \code{Source}}
\usage{
getScheme(
  source,
  scheme,
  first.year,
  last.year,
  year.aggregate.method,
  spatial.extent,
  spatial.extent.id,
  spatial.aggregate.method,
  subannual.resolution,
  subannual.original,
  subannual.aggregate.method,
  sta.info,
  quick.read.file = NULL,
  quick.read.autodelete = FALSE,
  averaged.source,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{source}{The \code{Source} object for which the Classification \code{Field} should be built. A list of \code{Source} objects can also be provided, in which case 
the required \code{Field} object derived from each \code{Source} in the list (for example LAI or fractional cover) are first averaged, and then do the biome 
classification. In the case of a list of \code{Source} objects, the \code{averaged.source} arguments (see below) must also be supplied so that the averaged 
data can be written to/read from disk.}

\item{scheme}{The classification scheme to be used as \code{Scheme} object, or the id of a \code{Scheme} defined in the package, as a character string.}

\item{first.year}{The first year (as a numeric) of the data to be return}

\item{last.year}{The last year (as a numeric) of the data to be return}

\item{year.aggregate.method}{A character string describing the method by which to annual aggregate the data.  Leave blank to apply no annual aggregation. Can currently be "mean", "sum", "max", "min", "mode", "median", "sd" and "var".
For technical reasons these need to be implemented in the package in the code however it should be easy to implement more, please just contact the author!  Note that this aggregation is done before the Scheme is calculated.
See \code{\link{aggregateYears}}}

\item{spatial.extent}{An extent in space to which this Field should be cropped, supplied as a raster::extent object or an object from which a raster::extent object can be derived - eg. a Raster* object or another Field object.}

\item{spatial.extent.id}{A character string to give an identifier for the spatial extent this ModelField covers.}

\item{spatial.aggregate.method}{A character string describing the method by which to spatially aggregate the data.  Leave blank to apply no spatially aggregation. Can currently be "weighted.mean", "w.mean", "mean", 
"mode", "median", weighted.sum", "w.sum", "sum", "max", "min", "sd" or "var".  For technical reasons these need to be implemented in the package in the code however it should be easy to implement more, please just contact the author!
Note that this aggregation is done before the Scheme is calculated.
See \code{\link{aggregateSpatial}}}

\item{subannual.resolution}{A character string specifying the subannual resolution that you want to the data on.  Can be "Year", "Month" or "Day".}

\item{subannual.original}{A character string specifying the subannual you want the data to be on before applying the subannual.aggregate.method. 
Can be "Year", "Month" or "Day".  Currently ignored.}

\item{subannual.aggregate.method}{A character string specifying the method by which to aggragte the data subannually,  can be "mean", "sum", "max", "min", "mode", "median", "sd" or "var".
Note that this aggregation is done before the Scheme is calculated.
See \code{\link{aggregateSubannual}}}

\item{sta.info}{Optionally an STAInfo object defining the exact spatial-temporal-annual domain over which the data should be retrieved.
Can also be a Field object from which the STA info will de derived.
If specified the following 9 arguments are ignored (with a warning).}

\item{quick.read.file}{A character string.  If set, the function will look for a file of this name (plus the extension ".RData") in the run directory.
If if finds one then it reads that.  If it doesn't find the appropriate file, then it reads the raw data, performs whatever cropping and aggregating is necessary,
and then saves the data in a file of that name (in the run directory) for use next time.  (Note: the function also checks that the specified layers, cropping and aggregating 
found in the file match that which was requested by the arguments here).}

\item{quick.read.autodelete}{If TRUE then the file specified by the above "quick.read.file" argument will be deleted, thus ensuring that the raw data will be read afresh 
(and saved again).  Ignored if valid "quick.read.file" argument not supplied.}

\item{averaged.source}{If a list of \code{Source} objects have been supplied to be averaged before the classification, you must supply another \code{Source} object to store the averaged results.}

\item{verbose}{If TRUE give a lot of information for debugging/checking.}

\item{...}{Other arguments that are passed to the getField function for the specific Format or additional arguements for selecting space/time/years.
For all Formats, the followings arguments apply:
\itemize{
 \item{\code{cover.fraction}}  When selecting gridcells based on a SpatialPolygonsDataFrame (ie from a shapefile) as the \code{spatial.extent} argument, this optional arguement determines 
 how much of the gridcell needs to be in the the polygon for it to be selected. Should be between 0 and 1.
}
For the aDGVM(1) Format, the following arguments apply:
\itemize{
 \item{\code{adgvm.file.type}}  This character string argument specifies from which file to read the data.
 This can be one of "Yearly", "Sys", "Fire", "Soil" or "Size".  The default is "Yearly", which is sensible because the yearly file is always written. 
 \item{\code{adgvm.fire}}  This numeric argument (taking values 0 or 1) specifies to take a run with fire on (1) or off (0). Default is 1.
 \item{\code{adgvm.climate}}   This numeric argument (taking values 0 or 1) specifies to take a run with constant (0) or transient (1) climate.  Default is 0.
 \item{\code{adgvm.header}} If your aDGVM run has been has extra columns added to the output tables, use this argument
 to specify the column names.  For the default column names see the source file \code{aDGVM1-Format}.
}
For the aDGVM2 Format, the following arguments apply:
\itemize{
 \item{\code{adgvm2.scheme}}  This numeric argument defines the aDGVM PFT scheme which can be 1 or 2.
 \item{\code{adgvm2.daily}}  A logical, set to true to read daily data (only for \code{adgvm2.scheme=1} and if daily data are provided in pop file)
}}
}
\value{
A \code{Field}.
}
\description{
Given a \code{Source} object and a \code{Scheme} object, return an appropriate spatially/temporal/annually-aggregated \code{Field} object with categorical values u based on the 
classification contained in the \code{Scheme}, optionally including spatial, temporal and annual cropping.
}
\details{
Note that because there are three types of aggregating available, the resulting \code{Field} object can a wide select of spatio-temporal dimensions.
To check what dimensions you have you can use \code{\link{getDimInfo}}
}
\examples{
\donttest{
 
# In this example we derive and plot the Smith et al 2014 and the 
# Forrest et al 2015 biome classifications    
 
# First define a Source
test.dir <- system.file("extdata", "LPJ-GUESS_Runs", "CentralEurope", package = "DGVMTools")
test.Source <- defineSource(name = "LPJ-GUESS run", dir = test.dir,  format = GUESS)

# Smith et al. 2014
Smith2014.biomes <- getScheme(source = test.Source, scheme = Smith2014BiomeScheme, 
                              year.aggregate.method = "mean")
print(plotSpatial(Smith2014.biomes))

# Forrest et al. 2014
Forrest2015.biomes <- getScheme(source = test.Source, scheme = Forrest2015BiomeScheme, 
                                year.aggregate.method = "mean")
print(plotSpatial(Forrest2015.biomes))

}
}
\seealso{
\code{\link{aggregateSubannual}}, \code{\link{aggregateSpatial}}, \code{\link{aggregateYears}}, \code{\link{getDimInfo}},  \code{\link{getField}}
}
\author{
Matthew Forrest \email{matthew.forrest@senckenberg.de}
}
